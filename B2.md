# Вариант Б2

### Задание 1 (10 баллов)
Вас подвели к двум комнатам, в каждой из которых может оказаться либо принцесса, либо тигр. На обеих комнатах написано одно и то же:  
"В обеих комнатах находятся принцессы".  

Дополнительно известно, что утверждение на двери первой комнаты ложно, если в комнате находится принцесса, и истинно, если в комнате находится тигр. Для второй комнаты все наоборот: утверждение на двери этой комнаты истинно, если в комнате находится принцесса, и ложно, если в комнате находится тигр.  

С помощью формального анализа определите, в какой комнате находится принцесса.

---

#### Решение

**Шаг 1: Формализация**

- P₁ = 1 — принцесса в комнате 1; P₁ = 0 — тигр
- P₂ = 1 — принцесса в комнате 2; P₂ = 0 — тигр
- Утверждение на табличках: T = «В обеих комнатах принцессы» = P₁ ∧ P₂

**Шаг 2: Условия истинности табличек**

Комната 1: 
- Если P₁ = 1 (принцесса), табличка ложна: T = 0
- Если P₁ = 0 (тигр), табличка истинна: T = 1

Формула: T ↔ ¬P₁, т.е. (P₁ ∧ P₂) ↔ ¬P₁

Комната 2:
- Если P₂ = 1 (принцесса), табличка истинна: T = 1
- Если P₂ = 0 (тигр), табличка ложна: T = 0

Формула: T ↔ P₂, т.е. (P₁ ∧ P₂) ↔ P₂

**Шаг 3: Решение системы**

Из условия для комнаты 2: (P₁ ∧ P₂) ↔ P₂

Это эквивалентно: P₂ → (P₁ ∧ P₂) и (P₁ ∧ P₂) → P₂

Вторая импликация всегда истинна. Первая: P₂ → P₁ (если P₂ = 1, то P₁ = 1)

Из условия для комнаты 1: (P₁ ∧ P₂) ↔ ¬P₁

Разберём случаи:
- Если P₁ = 1: (1 ∧ P₂) = ¬1 = 0, значит P₂ = 0
- Если P₁ = 0: (0 ∧ P₂) = ¬0 = 1, значит 0 = 1 — противоречие

**Шаг 4: Проверка**

При P₁ = 1, P₂ = 0:
- Табличка T = P₁ ∧ P₂ = 1 ∧ 0 = 0 (ложь)
- Комната 1: принцесса → табличка должна быть ложна ✓
- Комната 2: тигр → табличка должна быть ложна ✓

**Ответ:** Принцесса в **комнате 1**, тигр в комнате 2.

---

### Задание 2 (10 баллов)
Сформулируйте рассуждение на естественном языке и постройте доказательство методом резолюции, если доказательство существует:  

F1: ∀y (D(y) → ∃x (S(x) ∧ Q(x,y)))  
F2: ∀x (S(x) → ∀y (Z(y) → ¬Q(x,y)))  
R: ∀x (¬Z(x) → ¬D(x))

---

#### Решение

**Шаг 1: Интерпретация на естественном языке**

- D(y) — y является деталью
- S(x) — x является специалистом  
- Q(x,y) — x обслуживает y
- Z(y) — y находится на складе

**Рассуждение:**
- F1: Каждую деталь обслуживает какой-то специалист.
- F2: Специалисты не обслуживают детали на складе.
- R: Детали не на складе не являются деталями. (Эквивалентно: все детали на складе, т.е. D(x) → Z(x))

**Шаг 2: Преобразование в КНФ**

**F1:** ∀y (D(y) → ∃x (S(x) ∧ Q(x,y)))
- Сколемизация: ∀y (¬D(y) ∨ (S(f(y)) ∧ Q(f(y),y)))
- КНФ: (¬D(y) ∨ S(f(y))) ∧ (¬D(y) ∨ Q(f(y),y))
- Дизъюнкты: 
  - (1) ¬D(y) ∨ S(f(y))
  - (2) ¬D(y) ∨ Q(f(y),y)

**F2:** ∀x (S(x) → ∀y (Z(y) → ¬Q(x,y)))
- Эквивалентно: ∀x∀y (¬S(x) ∨ ¬Z(y) ∨ ¬Q(x,y))
- Дизъюнкт: (3) ¬S(x) ∨ ¬Z(y) ∨ ¬Q(x,y)

**¬R (отрицание заключения):** ¬(∀x (¬Z(x) → ¬D(x))) = ∃x (¬Z(x) ∧ D(x))
- Сколемизация: ¬Z(a) ∧ D(a)
- Дизъюнкты:
  - (4) ¬Z(a)
  - (5) D(a)

**Шаг 3: Метод резолюций**

(6) Из (1) и (5) с подстановкой y = a: S(f(a))  [резольвента ¬D(a) ∨ S(f(a)) и D(a)]

(7) Из (2) и (5) с подстановкой y = a: Q(f(a),a)  [резольвента ¬D(a) ∨ Q(f(a),a) и D(a)]

(8) Из (3) и (6) с x = f(a): ¬Z(y) ∨ ¬Q(f(a),y)  [резольвента ¬S(f(a)) ∨ ¬Z(y) ∨ ¬Q(f(a),y) и S(f(a))]

(9) Из (8) и (7) с y = a: ¬Z(a)  [резольвента ¬Z(a) ∨ ¬Q(f(a),a) и Q(f(a),a)]

(10) Из (9) и (4): пустой дизъюнкт □  [¬Z(a) уже есть в (4), но формально (9) совпадает с (4)]

Фактически (9) подтверждает (4), что означает непротиворечивость. Перепроверим:

На самом деле (4) и (9) — одно и то же, поэтому противоречия нет из этой ветки. Нужно найти другой путь или убедиться, что заключение следует.

**Альтернативная проверка:** Покажем, что из F1, F2 следует R.

Предположим D(a) и ¬Z(a). По F1: существует S(c) и Q(c,a). По F2: S(c) и Z(a) → ¬Q(c,a). Но ¬Z(a), поэтому условие Z(a) ложно, и F2 не даёт противоречия.

**Вывод:** Заключение R **НЕ следует** из посылок F1 и F2.

**Ответ:** Доказательство методом резолюций **не существует** — заключение не выводимо из посылок.

---

### Задание 3 (15 баллов)
Постройте конечный автомат, определяющий, делится ли вводимое двоичное число на 5. Число вводится со старших разрядов и заканчивается маркером конца #. Например, по введённой последовательности 101101# должен быть выдан ответ «ДА», а по введённой последовательности 1110# должен быть выдан ответ «НЕТ».

---

#### Решение

**Шаг 1: Идея**

При чтении двоичного числа слева направо, если текущее значение равно n, то:
- После чтения 0: новое значение = 2n
- После чтения 1: новое значение = 2n + 1

Нас интересует остаток от деления на 5, поэтому состояния автомата — остатки {0, 1, 2, 3, 4}.

**Шаг 2: Таблица переходов**

| Состояние (остаток) | Вход 0 | Вход 1 |
|---------------------|--------|--------|
| q₀ (остаток 0) | q₀ (2·0 mod 5 = 0) | q₁ (2·0+1 mod 5 = 1) |
| q₁ (остаток 1) | q₂ (2·1 mod 5 = 2) | q₃ (2·1+1 mod 5 = 3) |
| q₂ (остаток 2) | q₄ (2·2 mod 5 = 4) | q₀ (2·2+1 mod 5 = 0) |
| q₃ (остаток 3) | q₁ (2·3 mod 5 = 1) | q₂ (2·3+1 mod 5 = 2) |
| q₄ (остаток 4) | q₃ (2·4 mod 5 = 3) | q₄ (2·4+1 mod 5 = 4) |

**Шаг 3: Автомат**

- Состояния: Q = {q₀, q₁, q₂, q₃, q₄}
- Алфавит: Σ = {0, 1, #}
- Начальное состояние: q₀
- Принимающее состояние: q₀ (остаток 0 = делится на 5)
- При чтении # — выдаём ответ в зависимости от текущего состояния

**Шаг 4: Проверка примеров**

101101₂ = 45₁₀
- Начало: q₀
- 1: q₀ → q₁
- 0: q₁ → q₂
- 1: q₂ → q₀
- 1: q₀ → q₁
- 0: q₁ → q₂
- 1: q₂ → q₀
- #: состояние q₀ → «ДА» ✓ (45 mod 5 = 0)

1110₂ = 14₁₀
- Начало: q₀
- 1: q₀ → q₁
- 1: q₁ → q₃
- 1: q₃ → q₂
- 0: q₂ → q₄
- #: состояние q₄ → «НЕТ» ✓ (14 mod 5 = 4)

**Ответ:** 

```
Автомат A = ({q₀, q₁, q₂, q₃, q₄}, {0, 1, #}, δ, q₀, {q₀})

Функция переходов δ:
δ(q₀, 0) = q₀    δ(q₀, 1) = q₁
δ(q₁, 0) = q₂    δ(q₁, 1) = q₃
δ(q₂, 0) = q₄    δ(q₂, 1) = q₀
δ(q₃, 0) = q₁    δ(q₃, 1) = q₂
δ(q₄, 0) = q₃    δ(q₄, 1) = q₄

При # в состоянии q₀ → «ДА», иначе → «НЕТ»
```

---

### Задание 4 (10 баллов)
Докажите дедуктивным методом Флойда с использованием слабейшего предусловия, что результатом работы двух разных программ:  

**P1:**  
```
begin
    x := y - x;
    y := y - x;
end
```

**P2:**  
```
begin
    z := x;
    x := y;
    y := z;
end
```

является одно и то же: перестановка значений переменных x и y.

---

#### Решение

**Спецификация:** {x = a ∧ y = b} P {x = b ∧ y = a}

где a и b — начальные значения x и y.

---

**Программа P1:**

**Шаг 1:** Вычисляем wp справа налево.

Постусловие: R = {x = b ∧ y = a}

**Шаг 2:** wp("y := y - x", x = b ∧ y = a)
- Подставляем y - x вместо y: x = b ∧ (y - x) = a
- Получаем: x = b ∧ y = a + x = a + b

**Шаг 3:** wp("x := y - x", x = b ∧ y = a + b)
- Подставляем y - x вместо x: (y - x) = b ∧ y = a + b
- Получаем: y - x = b ∧ y = a + b
- Из y = a + b: (a + b) - x = b, значит x = a

Итого: **wp(P1, R) = {x = a ∧ y = a + b}**

**Шаг 4:** Проверка I → wp(P1, R)?
- I: x = a ∧ y = b
- wp: x = a ∧ y = a + b

Это НЕ эквивалентно! Нужно y = b, но wp требует y = a + b.

**Перепроверка:** Возможно, я неправильно понял условие. Пусть начальные значения x = a, y = b.

Выполним P1:
1. x := y - x → x = b - a
2. y := y - x → y = b - (b - a) = a

После P1: x = b - a, y = a — это **не** перестановка!

**Ошибка в условии задачи** или программа P1 неполная. Стандартный алгоритм обмена без третьей переменной:
```
x := x + y;
y := x - y;
x := x - y;
```

Но проверим исходную P1 ещё раз с тремя операциями... В условии только 2 оператора.

**Вывод для P1:** Программа P1 **некорректна** для перестановки значений.

---

**Программа P2:**

**Шаг 1:** Постусловие R = {x = b ∧ y = a}

**Шаг 2:** wp("y := z", x = b ∧ y = a)
- Подставляем z вместо y: x = b ∧ z = a

**Шаг 3:** wp("x := y", x = b ∧ z = a)
- Подставляем y вместо x: y = b ∧ z = a

**Шаг 4:** wp("z := x", y = b ∧ z = a)
- Подставляем x вместо z: y = b ∧ x = a

Итого: **wp(P2, R) = {x = a ∧ y = b}**

**Шаг 5:** Проверка I → wp(P2, R)
- I: x = a ∧ y = b
- wp: x = a ∧ y = b

I ≡ wp(P2, R) ✓

**Ответ:** 
- Программа **P2 корректна** — выполняет перестановку значений x и y.
- Программа **P1 некорректна** в представленном виде (результат: x = b - a, y = a, а не x = b, y = a).

---

### Задание 5 (15 баллов)
Выразите в LTL следующие свойства:  

a. Я выйду замуж точно один раз.  
b. Я выйду замуж не менее одного раза.  
c. Я выйду замуж точно два раза.  
d. Я выйду замуж не более двух раз.

---

#### Решение

Пусть m — атомарное высказывание «я выхожу замуж (в данный момент времени)».

**a) Точно один раз**

«Когда-нибудь m, и после этого m больше никогда не будет»

Формула: **F(m ∧ X G ¬m) ∧ (¬m U m)**

Или эквивалентно: **(¬m U (m ∧ X G ¬m))**

Это означает: m не выполняется до первого раза, потом m выполняется ровно один раз, после чего навсегда ¬m.

---

**b) Не менее одного раза**

«Когда-нибудь произойдёт m»

Формула: **F m**

---

**c) Точно два раза**

«Сначала m не выполняется, потом первый раз m, потом m не выполняется, потом второй раз m, после этого m никогда»

Формула: **¬m U (m ∧ X(¬m U (m ∧ X G ¬m)))**

Или: **F(m ∧ X F(m ∧ X G ¬m)) ∧ ¬m U m ∧ X(¬m U (m ∧ X G ¬m))**

Упрощённо: **(¬m U (m ∧ X(¬m U (m ∧ X G ¬m))))**

---

**d) Не более двух раз**

«Если m случится в первый раз, то после второго раза m больше не будет» ИЛИ «m случится 0, 1 или 2 раза»

Формула: **G(m → X G(m → X G ¬m))**

Это означает: после каждого m, если будет ещё один m, то после него m уже не будет.

Альтернативная запись: **G(m → X(¬m U (m → X G ¬m) ∨ G ¬m))**

Более простая форма: **¬F(m ∧ X F(m ∧ X F m))**

(Неверно, что существуют три момента с m)

---

### Задание 6 (10 баллов)
Пусть M = (S, S₀, R, AP, L) – такая структура Крипке:  
S = {s₀, s₁, s₂, s₃}  
S₀ = {(s₁, s₂)}  
R = {(s₂, s₃), (s₂, s₀), (s₀, s₁), (s₁, s₂),(s₂, s₂)}}  
AP = {a, b}  
L(s₀) = {a}, L(s₁) = {a, b}, L(s₂) = {b}, L(s₃) = ∅  

В каких состояниях М выполняются формулы CTL: A(EX b U a)?

---

#### Решение

**Примечание:** В условии, вероятно, опечатка в S₀ = {(s₁, s₂)} — должно быть S₀ = {s₁, s₂} (множество начальных состояний). Также лишняя скобка в R.

**Шаг 1: Построение графа**

```
s₀ → s₁
s₁ → s₂
s₂ → s₃, s₂ → s₀, s₂ → s₂ (петля)
```

Обратите внимание: из s₃ нет переходов — это тупиковое состояние!

**Шаг 2: Анализ формулы A(EX b U a)**

Формула A(φ U ψ) означает: на ВСЕХ путях выполняется φ U ψ.

φ U ψ: φ выполняется до тех пор, пока не выполнится ψ, и ψ обязательно выполнится.

Здесь: φ = EX b, ψ = a.

**Шаг 3: Вычисление EX b**

EX b: существует переход в состояние с b.

- s₀: преемник s₁, L(s₁) = {a, b} содержит b → EX b ✓
- s₁: преемник s₂, L(s₂) = {b} → EX b ✓
- s₂: преемники s₃, s₀, s₂; L(s₂) = {b} → EX b ✓
- s₃: нет преемников → EX b ✗

**Шаг 4: Вычисление A(EX b U a)**

Состояние удовлетворяет A(EX b U a), если на всех путях из него:
- либо сейчас a
- либо сейчас EX b, и на всех путях продолжается EX b до a

Состояния с a: s₀ (L(s₀) = {a}), s₁ (L(s₁) = {a, b})

**Анализ по состояниям:**

**s₁:** a ∈ L(s₁) → A(EX b U a) выполняется ✓

**s₀:** a ∈ L(s₀) → A(EX b U a) выполняется ✓

**s₂:** a ∉ L(s₂), но EX b ✓
- Пути из s₂: 
  - s₂ → s₀ (a ✓)
  - s₂ → s₂ → ... (петля, EX b сохраняется)
  - s₂ → s₃ (EX b ✗ в s₃, и a ∉ L(s₃))

Путь s₂ → s₃: в s₃ нет a и нет EX b → A(EX b U a) нарушается!

**s₂:** A(EX b U a) **не выполняется** ✗

**s₃:** a ∉ L(s₃), EX b ✗ → A(EX b U a) **не выполняется** ✗

**Ответ:** Формула A(EX b U a) выполняется в состояниях **s₀ и s₁**.