# Вариант И9

### Задание 1 (5 баллов)
Выразите:

a) функцию ⊕ суперпозицией функций И и ИЛИ;

b) дизъюнкцию с помощью импликации и нуля (константы 0).

---

#### Решение

**a) Выразить ⊕ через И (∧) и ИЛИ (∨)**

XOR: a ⊕ b = 1, когда ровно один из аргументов равен 1.

a ⊕ b = (a ∨ b) ∧ ¬(a ∧ b)

Но нужно выразить ¬ через ∧ и ∨. **Это невозможно**, так как {∧, ∨} не является полной системой — все функции из этой системы сохраняют 0 и 1, а ⊕ не сохраняет 1 (1⊕1=0).

**Ответ:** Невозможно выразить ⊕ только через И и ИЛИ.

Если допускается использование отрицания:
**a ⊕ b = (a ∨ b) ∧ (¬a ∨ ¬b) = (a ∧ ¬b) ∨ (¬a ∧ b)**

---

**b) Выразить ∨ через → и 0**

Используем свойство импликации:
¬a = a → 0

a ∨ b = ¬a → b = (a → 0) → b

**Проверка:**
- a=0, b=0: (0→0)→0 = 1→0 = 0 ✓
- a=0, b=1: (0→0)→1 = 1→1 = 1 ✓
- a=1, b=0: (1→0)→0 = 0→0 = 1 ✓
- a=1, b=1: (1→0)→1 = 0→1 = 1 ✓

**Ответ:** a ∨ b = (a → 0) → b

---

### Задание 2 (10 баллов)
На Всемирном Конгрессе сепульковедов Станислав Лем рассказал о последних исследованиях, которые привели к следующим открытиям в области сепулек:

"Сепульки бывают либо полифренические, либо монофренические. Если сепульки гомозиготны, то они полифренические, но если они не гомозиготны, то они либо монофренические, либо пчмы. Если сепульки монофренические или пчмы, то они гомоморфны. Кроме того, сепульки являются мультифобными, если они гомоморфы."

Молодой учёный сделал вывод: можно логически вывести новое знание: "Если сепульки не гомоморфны, то они не гомозиготны." Проверьте логическую корректность такого вывода (доказательство / опровержение).

---

#### Решение

**Введём обозначения:**
- P — полифренические
- M — монофренические
- G — гомозиготны
- H — гомоморфны
- C — пчмы (от слова pchmy)
- F — мультифобные

**Формализация посылок:**

1. P ∨ M (полифренические или монофренические)
2. G → P (гомозиготны → полифренические)
3. ¬G → (M ∨ C) (не гомозиготны → монофренические или пчмы)
4. (M ∨ C) → H (монофренические или пчмы → гомоморфны)
5. H → F (гомоморфны → мультифобны)

**Вывод для проверки:** ¬H → ¬G

**Доказательство методом контрапозиции:**

Докажем эквивалентное утверждение: G → H

Цепочка:
- Если G, то P (по посылке 2)
- Но это не даёт нам H напрямую...

Попробуем другой путь. Докажем ¬H → ¬G напрямую:

Предположим ¬H (не гомоморфны).

По контрапозиции посылки 4: ¬H → ¬(M ∨ C) = ¬M ∧ ¬C

Значит, ¬M и ¬C.

По контрапозиции посылки 3: ¬(M ∨ C) → G, т.е. (¬M ∧ ¬C) → G

Из ¬M ∧ ¬C следует G.

Но нам нужно доказать ¬G. Получили противоречие?

**Проверим логику:**

Посылка 3: ¬G → (M ∨ C)
Контрапозиция: ¬(M ∨ C) → G, т.е. (¬M ∧ ¬C) → G

Из ¬H по п.4: ¬M ∧ ¬C
Из (¬M ∧ ¬C) по контрапозиции п.3: G

Получается: ¬H → G, что эквивалентно ¬G → H.

Контрапозиция: ¬H → G, что противоположно нужному ¬H → ¬G!

**Вывод:** Из посылок следует ¬H → G (если не гомоморфны, то гомозиготны), а не ¬H → ¬G.

**Ответ:** Вывод молодого учёного **логически некорректен**. Из посылок следует обратное: ¬H → G.

---

### Задание 3 (10 баллов)
Для каждой пары атомарных предикатов постройте наиболее общий унификатор, если он существует:

a) P(A, B, B) и P(x, y, z)

б) Q(u, G(b, z)) и Q(G(x, z), y)

в) Older(Mother(y), z) и Older(Mother(z), John)

г) R(x, f(x, g(y))) и R(g(y), f(g(a), z))

д) Knows(F(v), a) и Knows(x, z)

---

#### Решение

**a) P(A, B, B) и P(x, y, z)**

A, B — константы; x, y, z — переменные.

Уравнения:
- x = A
- y = B
- z = B

**НОУ (наиболее общий унификатор):** σ = {x/A, y/B, z/B}

---

**б) Q(u, G(b, z)) и Q(G(x, z), y)**

Уравнения:
- u = G(x, z)
- G(b, z) = y, т.е. y = G(b, z)

Проверка: переменные не входят циклически.

**НОУ:** σ = {u/G(x, z), y/G(b, z)}

Но x и z свободны, так что можно записать:
**σ = {u/G(x, z), y/G(b, z)}**

---

**в) Older(Mother(y), z) и Older(Mother(z), John)**

Уравнения:
- Mother(y) = Mother(z) → y = z
- z = John

Из z = John и y = z: y = John.

**НОУ:** σ = {y/John, z/John}

---

**г) R(x, f(x, g(y))) и R(g(y), f(g(a), z))**

Уравнения:
- x = g(y)
- f(x, g(y)) = f(g(a), z)

Из второго уравнения:
- x = g(a)
- g(y) = z

Из x = g(y) и x = g(a): g(y) = g(a) → y = a

Тогда z = g(y) = g(a).

Проверка: x = g(y) = g(a) ✓

**НОУ:** σ = {x/g(a), y/a, z/g(a)}

---

**д) Knows(F(v), a) и Knows(x, z)**

Уравнения:
- F(v) = x, т.е. x = F(v)
- a = z, т.е. z = a

**НОУ:** σ = {x/F(v), z/a}

---

### Задание 4 (20 баллов)
Проверьте корректность следующей программы целого умножения, предварительно построив инвариант цикла:

{ true } z := 0; i := 0; while i != y do z := z + x; i := i + 1 od { z = x * y }

---

#### Решение

**Программа:**
```
z := 0;
i := 0;
while i != y do
    z := z + x;
    i := i + 1
od
```

**Предусловие:** true
**Постусловие:** z = x * y

**Шаг 1: Построение инварианта цикла**

Инвариант должен:
1. Выполняться перед первой итерацией
2. Сохраняться после каждой итерации
3. Вместе с условием выхода давать постусловие

**Инвариант:** I ≡ (z = x * i)

**Шаг 2: Проверка инварианта перед циклом**

После z := 0; i := 0:
- z = 0, i = 0
- z = x * i → 0 = x * 0 = 0 ✓

**Шаг 3: Сохранение инварианта**

Предположим: z = x * i (инвариант) и i ≠ y (условие цикла).

После z := z + x; i := i + 1:
- z' = z + x = x * i + x = x * (i + 1)
- i' = i + 1
- z' = x * i' ✓

Инвариант сохраняется.

**Шаг 4: Получение постусловия**

При выходе из цикла: i = y и z = x * i.
Значит z = x * y. ✓

**Шаг 5: Завершаемость**

Вариантная функция: V = y - i (при y ≥ 0)

- При i ≠ y и y > i: V > 0
- После итерации: V' = y - (i+1) = V - 1

V убывает и ограничена снизу, значит цикл завершается (при y ≥ 0).

**Важное замечание:** Программа корректна только для y ≥ 0. При y < 0 цикл не завершится.

**Ответ:** Программа **частично корректна**. При добавлении предусловия y ≥ 0 программа **полностью корректна**.

---

### Задание 5 (15 баллов)
Выразите формулой LTL следующие свойства бесконечных вычислений (считайте, что в каждом состоянии выполняется не более одного события):

a) Атомарные предикаты p и q выполняются попеременно: (в одном состоянии p и q не встречаются; если выполняется p, то после этого p не будет выполняться, пока не выполнится q, и наоборот).

б) Если произойдёт событие p, то когда-нибудь в будущем выполнится событие q, а сразу за этим произойдёт событие r.

в) Если случится событие p, то в будущем обязательно встретится событие q, а между ними не случится событие r.

---

#### Решение

**a) p и q выполняются попеременно**

Условия:
1. p и q не выполняются одновременно: G(¬(p ∧ q))
2. После p до следующего p должно быть q: G(p → X(¬p U q))
3. После q до следующего q должно быть p: G(q → X(¬q U p))

**Формула:** G(¬(p ∧ q)) ∧ G(p → X(¬p U q)) ∧ G(q → X(¬q U p))

---

**б) Если p, то когда-нибудь q, а сразу за ним r**

"Сразу за q происходит r" означает X r после q.

**Формула:** G(p → F(q ∧ X r))

Расшифровка: Всегда, если p, то когда-нибудь (q и в следующий момент r).

---

**в) Если p, то в будущем q, а между ними нет r**

"Между p и q нет r" — это (¬r) U q.

**Формула:** G(p → (¬r U q))

Расшифровка: Всегда, если p, то ¬r выполняется до тех пор, пока не наступит q.

Примечание: оператор U является сильным, т.е. q обязательно наступит.

---

### Задание 6 (10 баллов)
Пусть M = (S, S₀, R, AP, L) — такая структура Крипке:  
S = {s1, s2, s3},  S₀ = {s1},  R = {(s1, s2), (s1, s3), (s2, s1), (s2, s3), (s3, s3)}  
AP = {a, b, c},  L(s1) = {a, b},  L(s2) = {b, c},  L(s3) = {c}.

Проверьте, является ли M моделью формулы AG(EF b).

---

#### Решение

**Структура Крипке:**

```
       s1{a,b}
      ↙    ↘
   s2{b,c} → s3{c}
      ↓       ↺
     s1
```

Переходы:
- s1 → s2, s1 → s3
- s2 → s1, s2 → s3
- s3 → s3 (только петля)

**Формула: AG(EF b)**

AG φ означает: на всех путях во всех состояниях выполняется φ.
EF b означает: существует путь, на котором когда-нибудь b.

**Шаг 1: Определим, где выполняется b**

- L(s1) = {a, b} → b = 1
- L(s2) = {b, c} → b = 1
- L(s3) = {c} → b = 0

**Шаг 2: Вычислим EF b для каждого состояния**

EF b = μZ.(b ∨ EX Z) — наименьшая неподвижная точка.

**Итерация 0:** Z₀ = ∅

**Итерация 1:** Z₁ = {s | b(s) = 1} = {s1, s2}

**Итерация 2:** Z₂ = Z₁ ∪ {s | EX Z₁}
- s3: переходы только в s3, s3 ∉ Z₁, EX Z₁ = 0
- Z₂ = {s1, s2}

Неподвижная точка: EF b = {s1, s2}

**Шаг 3: Проверим EF b в s3**

В s3: EF b = 0, так как из s3 доступен только s3 (петля), а b(s3) = 0.

**Шаг 4: Проверим AG(EF b)**

AG требует, чтобы EF b выполнялось во всех достижимых состояниях.

Из s1 достижимы: s1, s2, s3.

В s3: EF b = 0.

Значит, AG(EF b) не выполняется, так как существует достижимое состояние (s3), где EF b ложно.

**Ответ:** M ⊭ AG(EF b). **Формула не выполняется.**

Причина: из состояния s3 невозможно достичь состояния с b.