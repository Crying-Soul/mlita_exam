# Вариант M12

(Σ 70 баллов)

### Задание 1 (5 баллов)
Выразите только с помощью функции «штрих Шеффера» (|) следующие функции: True, False, AND, OR, NOT, импликацию.

---

#### Решение

Штрих Шеффера: a | b = ¬(a ∧ b) (NAND)

**NOT (отрицание):**
¬a = a | a

Проверка: a | a = ¬(a ∧ a) = ¬a ✓

**AND (конъюнкция):**
a ∧ b = ¬(a | b) = (a | b) | (a | b)

Проверка: (a | b) | (a | b) = ¬(a | b) = ¬¬(a ∧ b) = a ∧ b ✓

**OR (дизъюнкция):**
a ∨ b = ¬a | ¬b = (a | a) | (b | b)

Проверка: (a | a) | (b | b) = ¬a | ¬b = ¬(¬a ∧ ¬b) = a ∨ b ✓

**TRUE (константа 1):**
True = a | ¬a = a | (a | a)

Или проще: True = ¬False = (a | a) | a для любого a... 

На самом деле: True = (a | a) | a = ¬a | a = ¬(¬a ∧ a) = ¬0 = 1 ✓

**FALSE (константа 0):**
False = ¬True = True | True

Где True = (a | a) | a, тогда False = ((a | a) | a) | ((a | a) | a)

Или: False = (a ∧ ¬a) = ((a | a) | (a | a)) | ((a | a) | (a | a))... сложно.

Проще: False = ¬(a | a | ... ) при a=0 не работает...

False = ((a | a) | a) | ((a | a) | a) = 1 | 1 = ¬(1 ∧ 1) = 0 ✓

**Импликация (a → b):**
a → b = ¬a ∨ b = (a | a) | (b | b)... нет, это a ∨ b.

a → b = ¬a ∨ b = ¬(a ∧ ¬b) = a | ¬b = a | (b | b)

Проверка: a | (b | b) = a | ¬b = ¬(a ∧ ¬b) = ¬a ∨ b = a → b ✓

**Итоговые формулы:**
- NOT a = a | a
- AND(a,b) = (a | b) | (a | b)
- OR(a,b) = (a | a) | (b | b)
- TRUE = (a | a) | a (для любого a)
- FALSE = TRUE | TRUE = ((a|a)|a) | ((a|a)|a)
- a → b = a | (b | b)

---

### Задание 2 (10 баллов)
Пусть справедлива теорема: «Для того чтобы хроничные сеульки были латентными, необходимо, чтобы они были контрарными.»
Какие из следующих утверждений являются следствиями этой теоремы?

a) Контрарные сеульки латентны.

б) Неверно, что отсутствие у сеульки свойства контрарности достаточно для того, чтобы она была не хроничной, но латентной.

в) Отсутствие у сеульки свойства контрарности не является необходимым для того, чтобы она была не латентной, но при этом латентной.

(Дайте формальное объяснение, какие утверждения следуют и почему.)

---

#### Решение

**Обозначения:**
- H — хроничная сеулька
- L — латентная сеулька
- K — контрарная сеулька

**Теорема:** "Чтобы хроничные были латентными, необходимо, чтобы они были контрарными."

Формализация: (H ∧ L) → K

Эквивалентно: H → (L → K), или "если хроничная и латентная, то контрарная".

**Анализ утверждений:**

**a) Контрарные сеульки латентны: K → L**

Из (H ∧ L) → K не следует K → L.

Контрмодель: H = 0, L = 0, K = 1.
- (H ∧ L) → K = (0 ∧ 0) → 1 = 0 → 1 = 1 ✓ (теорема выполнена)
- K → L = 1 → 0 = 0 (утверждение ложно)

**a) НЕ следует.**

---

**б) Неверно, что ¬K достаточно для (¬H ∧ L)**

"¬K достаточно для (¬H ∧ L)" = ¬K → (¬H ∧ L)

Утверждение б: ¬(¬K → (¬H ∧ L))

Из теоремы (H ∧ L) → K следует контрапозиция: ¬K → ¬(H ∧ L) = ¬K → (¬H ∨ ¬L)

Проверим: ¬K → (¬H ∧ L) совместимо с ¬K → (¬H ∨ ¬L)?

Если ¬K истинно, то из теоремы: ¬H ∨ ¬L.
При этом ¬H ∧ L требует ¬H = 1 и L = 1.
Но ¬H = 1 совместимо с ¬H ∨ ¬L.

Так что ¬K → (¬H ∧ L) не обязательно ложно.

Контрмодель для утверждения б:
Пусть K = 0 (¬K = 1), H = 0 (¬H = 1), L = 1.
- Теорема: (0 ∧ 1) → 0 = 0 → 0 = 1 ✓
- ¬K → (¬H ∧ L) = 1 → (1 ∧ 1) = 1 → 1 = 1

Утверждение б говорит, что это должно быть ложно, но оно истинно.

**б) НЕ следует.**

---

**в) ¬K не является необходимым для (¬L ∧ L)**

"¬L ∧ L" — это противоречие (всегда ложно).

"¬K необходимо для (¬L ∧ L)" = (¬L ∧ L) → ¬K

Но ¬L ∧ L = 0 всегда, поэтому 0 → ¬K = 1 всегда.

Утверждение: "¬K не является необходимым" = ¬((¬L ∧ L) → ¬K) = ¬1 = 0.

Это ложно!

Но подождём — возможно, в формулировке "не латентной, но при этом латентной" — это описка? 

Если читать как "не латентной" = ¬L, то утверждение становится бессмысленным.

**в) НЕ следует** (утверждение о противоречивом условии не может быть содержательным следствием).

**Ответ:** Ни одно из утверждений a), б), в) **не является следствием** теоремы.

---

### Задание 3 (10 баллов)
Проверьте правильность следующего рассуждения методом резолюций:

"В классе есть те, кто любит лазить по горам. Каждый, кто любит лазить по горам, любит кататься на велосипеде. Таким образом, в классе есть те, кто любит кататься на велосипеде."

(Проведите формальное доказательство методом резолюций, если возможно.)

---

#### Решение

**Формализация:**

Предикаты:
- C(x) — x в классе
- M(x) — x любит лазить по горам (mountains)
- B(x) — x любит кататься на велосипеде (bicycle)

**Посылки:**
1. ∃x (C(x) ∧ M(x)) — в классе есть любители гор
2. ∀x (M(x) → B(x)) — любители гор любят велосипед

**Заключение:** ∃x (C(x) ∧ B(x)) — в классе есть любители велосипеда

**Преобразование в клаузальную форму:**

Посылка 1: ∃x (C(x) ∧ M(x))
Сколемизация: C(a) ∧ M(a), где a — сколемовская константа

Клаузы:
- C(a)
- M(a)

Посылка 2: ∀x (M(x) → B(x)) = ∀x (¬M(x) ∨ B(x))
Клауза: ¬M(x) ∨ B(x)

**Отрицание заключения:**
¬∃x (C(x) ∧ B(x)) = ∀x ¬(C(x) ∧ B(x)) = ∀x (¬C(x) ∨ ¬B(x))
Клауза: ¬C(x) ∨ ¬B(x)

**Множество клауз:**
1. C(a)
2. M(a)
3. ¬M(x) ∨ B(x)
4. ¬C(y) ∨ ¬B(y)

**Резолюции:**

5. Из 2 и 3 (унификация x = a): B(a)

6. Из 1 и 4 (унификация y = a): ¬B(a)

7. Из 5 и 6: □ (пустая клауза)

**Получено противоречие!**

**Ответ:** Рассуждение **логически корректно**. Заключение следует из посылок.

---

### Задание 4 (20 баллов)
Проверьте корректность программы методом Флойда:

{ x ≥ 0 }  
f := 1; z := 0;  
while z ≠ x do  
    f := f * z;  
    z := z + 1;  
end 
{ f = x! }

---

#### Решение

**Анализ программы:**

```
f := 1; z := 0;
while z ≠ x do
    f := f * z;    // Умножаем f на z
    z := z + 1;
end
```

**Проблема:** На первой итерации z = 0, и f := f * 0 = 0.

После этого f = 0 навсегда!

**Проверка на примере x = 3:**

- Начало: f = 1, z = 0
- Итерация 1: f = 1 * 0 = 0, z = 1
- Итерация 2: f = 0 * 1 = 0, z = 2
- Итерация 3: f = 0 * 2 = 0, z = 3
- Выход: z = 3 = x
- Результат: f = 0 ≠ 3! = 6

**Программа некорректна!**

**Правильная версия** должна быть:
```
f := 1; z := 0;
while z ≠ x do
    z := z + 1;
    f := f * z;
end
```

Или:
```
f := 1; z := 1;
while z ≤ x do
    f := f * z;
    z := z + 1;
end
```

**Построение инварианта для правильной программы:**

Для исправленной версии: I ≡ (f = z! ∧ z ≤ x)

**Ответ:** Программа **некорректна**.

Ошибка: порядок операций неверный — сначала умножается на 0, что обнуляет f.

**Контрпример:** При x = 3 программа возвращает f = 0, а не 6.

---

### Задание 5 (10 баллов)
Приведите для каждой формулы вычисление, которое ей удовлетворяет, и вычисление, которое ей не удовлетворяет:

a) G(p ⇒ p U q)

б) F q ⇒ (¬p) U q

---

#### Решение

**a) G(p → p U q)**

Формула: всегда, если p, то p U q (p выполняется до q).

**Удовлетворяющее вычисление:**

σ = {q}→{q}→{q}→...

- p = 0 везде, импликация p → (p U q) = 0 → ? = 1 ✓
- G(1) = 1 ✓

**Другой пример:**

σ = {p}→{p,q}→{q}→{q}→...

- s₀: p = 1, p U q? В s₁ есть q и p, значит p U q = 1 (q достигнуто). p → (p U q) = 1 ✓
- s₁: p = 1, q = 1, p U q = 1 (q в текущем). p → 1 = 1 ✓
- s₂, s₃, ...: p = 0, импликация = 1 ✓
- G(...) = 1 ✓

**Не удовлетворяющее вычисление:**

σ = {p}→{p}→{p}→... (бесконечно p, никогда q)

- s₀: p = 1, p U q? p выполняется, но q никогда не наступит. p U q = 0 (сильный U требует q).
- p → (p U q) = 1 → 0 = 0
- G(0) = 0 ✗

---

**б) F q → (¬p) U q**

Формула: если когда-нибудь q, то ¬p до q.

**Удовлетворяющее вычисление (антецедент ложен):**

σ = {p}→{p}→{p}→... (никогда q)

- F q = 0
- 0 → ? = 1 ✓

**Удовлетворяющее вычисление (консеквент истинен):**

σ = {}→{}→{q}→...

- F q = 1 (q в s₂)
- (¬p) U q: в s₀ и s₁ p = 0 (¬p = 1), в s₂ q = 1. (¬p) U q = 1 ✓
- 1 → 1 = 1 ✓

**Не удовлетворяющее вычисление:**

σ = {p}→{q}→...

- F q = 1 (q в s₁)
- (¬p) U q: в s₀ p = 1, ¬p = 0. Нужно ¬p до q, но ¬p = 0 в s₀. 
- (¬p) U q = 0 (p нарушает ¬p до q)
- 1 → 0 = 0 ✗

---

### Задание 6 (15 баллов)
Задана структура Крипке, описывающая граф переходов системы управления микроволновой печью:

Матрица смежности (порядок вершин: s, d, (d,s), p, (p,s), (d,p,s)):

| from \ to | s | d | (d,s) | p | (p,s) | (d,p,s) |
|---:|:-:|:-:|:-:|:-:|:-:|:-:|
| **s**       | 0 | 1 | 0 | 1 | 1 | 0 |
| **d**       | 0 | 0 | 1 | 0 | 0 | 0 |
| **(d,s)**   | 1 | 0 | 0 | 0 | 1 | 0 |
| **p**       | 0 | 0 | 0 | 0 | 1 | 0 |
| **(p,s)**   | 0 | 0 | 0 | 0 | 0 | 1 |
| **(d,p,s)** | 0 | 0 | 0 | 1 | 1 | 0 |

Здесь: d — «дверца печи закрыта», p — «СВЧ излучение включено», s — «кнопка ‘ПУСК’ нажата».

Требование: «Из любого состояния существует возможность возврата в начальное состояние».

a) Запишите это требование в виде формулы CTL (предположите, что предикат init истинно только в начальном состоянии s).

b) Формально проверьте выполнение формулы на заданном графе (обоснуйте, выполняется ли AG EF init в каждом состоянии).

---

#### Решение

**a) Формула CTL**

**AG EF init**

(Означает: "Всегда (AG), из любого будущего момента, возможно (EF) попасть в init").

**b) Проверка на графе**

**Шаг 1: Построение графа структуры Крипке**

```
        ┌────────────────────────────────────────────────────────┐
        │                                                        │
        ▼                                                        │
   ┌─────────┐      ┌─────────┐      ┌─────────┐                │
   │    s    │─────►│    d    │─────►│  (d,s)  │────────────────┘
   │  init   │      │         │      │         │
   └─────────┘      └─────────┘      └─────────┘
        │                                 │
        │                                 │
        │                                 ▼
        │           ┌─────────────────────────┐
        │           │                         │
        │           ▼                         │
        │      ┌─────────┐      ┌─────────┐   │
        ├─────►│    p    │─────►│  (p,s)  │───┘
        │      └─────────┘      └─────────┘
        │           ▲                │
        │           │                │
        │           │                ▼
        │           │          ┌─────────┐
        │      ┌────┴──────────│ (d,p,s) │
        │      │               └─────────┘
        │      │                    │
        ▼      │                    │
   ┌─────────┐ │                    │
   │  (p,s)  │◄┴────────────────────┘
   └─────────┘
```

Переходы по матрице смежности:
1. s → d, p, (p,s)
2. d → (d,s)
3. (d,s) → s, (p,s)
4. p → (p,s)
5. (p,s) → (d,p,s)
6. (d,p,s) → p, (p,s)

**Шаг 2: Анализ компонент сильной связности (SCC)**

Заметим цикл:
p → (p,s) → (d,p,s) → p → ...

Эти три состояния {p, (p,s), (d,p,s)} образуют замкнутую компоненту ("ловушку"), из которой **нет переходов** во внешние состояния (s, d, (d,s)).

Следовательно, если система попала в состояние p (а это возможно из начального состояния s → p), она никогда не вернется в s (которое является init).

**Шаг 3: Вычисление EF init методом неподвижной точки**

EF init = μZ. (init ∨ EX Z)

Итерация:
- Z₀ = ∅
- Z₁ = init ∨ EX ∅ = {s}
- Z₂ = {s} ∨ EX{s} = {s} ∪ {состояния с переходом в s} = {s, (d,s)}
- Z₃ = {s, (d,s)} ∨ EX{s, (d,s)} = {s, (d,s)} ∪ {d} = {s, d, (d,s)}
- Z₄ = {s, d, (d,s)} ∪ EX{s, d, (d,s)} = {s, d, (d,s)} ∪ {s} = {s, d, (d,s)}

Неподвижная точка достигнута: **EF init = {s, d, (d,s)}**

**Состояния, где EF init ЛОЖНО: {p, (p,s), (d,p,s)}**

**Шаг 4: Проверка AG EF init**

Поскольку EF init ложно в состояниях {p, (p,s), (d,p,s)}, которые достижимы из s (например, s → p), то AG EF init ложно в s.

Формально: AG EF init требует, чтобы на ВСЕХ путях из s, во ВСЕХ состояниях выполнялось EF init. Но путь s → p ведёт в состояние, где EF init ложно.

**Ответ:** Формула **AG EF init НЕ выполняется**.
