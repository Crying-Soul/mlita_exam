# Вариант O14

(Σ 70 баллов)

### Задание 1 (10 баллов)
Выразите:

a) отрицание через импликацию и константу 0;

б) дизъюнкцию и конъюнкцию через импликацию и отрицание;

в) функцию F суперпозицией функций И и ИЛИ.

---

#### Решение

**a) Отрицание через импликацию и 0**

¬a = a → 0

Проверка:
- a = 0: 0 → 0 = 1 = ¬0 ✓
- a = 1: 1 → 0 = 0 = ¬1 ✓

---

**б) Дизъюнкция и конъюнкция через → и ¬**

**Дизъюнкция:**
a ∨ b = ¬a → b

Проверка: ¬a → b = ¬(¬a) ∨ b = a ∨ b ✓

**Конъюнкция:**
a ∧ b = ¬(a → ¬b)

Проверка: a → ¬b = ¬a ∨ ¬b, ¬(¬a ∨ ¬b) = a ∧ b ✓

---

**в) Функция F через И и ИЛИ**

Без указания конкретной функции F невозможно дать ответ.

Если F — это какая-то конкретная функция (например, XOR или что-то другое), то ответ зависит от F.

**Замечание:** Система {∧, ∨} не является функционально полной, так как все функции в ней сохраняют 0 и 1. Поэтому не все функции можно выразить через И и ИЛИ.

Если F сохраняет 0 и 1 (F(0,0,...,0) = 0, F(1,1,...,1) = 1), то её можно выразить в ДНФ/КНФ без отрицания.

---

### Задание 2 (10 баллов)
Проверьте методом резолюций правильность следующих рассуждений:

a) Некоторые студенты боятся сепулек. Ни одна студентка не боится грымзиков. Следовательно, ни одна сепулка не является грымзиком.

б) Датчане не любят кофе. Некоторые любители кофе умны. Следовательно, некоторые датчане не умны.

(Формализуйте и проверьте корректность).

---

#### Решение

**a) Анализ рассуждения**

Предикаты:
- S(x) — x студент
- Sep(x) — x боится сепулек
- G(x) — x боится грымзиков
- Sепулка(x) — x сепулка
- Грымзик(x) — x грымзик

Посылки:
1. ∃x (S(x) ∧ Sep(x)) — некоторые студенты боятся сепулек
2. ∀x (S(x) → ¬G(x)) — ни одна студентка не боится грымзиков

Заключение: ∀x (Sепулка(x) → ¬Грымзик(x))

**Проблема:** Посылки говорят о страхе перед сепульками/грымзиками, а заключение — о том, являются ли объекты сепульками или грымзиками. Это разные вещи!

**Рассуждение некорректно** — связь между "бояться X" и "быть X" не установлена.

---

**б) Анализ рассуждения**

Предикаты:
- D(x) — x датчанин
- C(x) — x любит кофе
- U(x) — x умный

Посылки:
1. ∀x (D(x) → ¬C(x)) — датчане не любят кофе
2. ∃x (C(x) ∧ U(x)) — некоторые любители кофе умны

Заключение: ∃x (D(x) ∧ ¬U(x)) — некоторые датчане не умны

**Метод резолюций:**

Клаузальная форма:
1. ¬D(x) ∨ ¬C(x)
2. C(a) (сколемизация)
3. U(a)

Отрицание заключения: ∀x (D(x) → U(x)) = ¬D(y) ∨ U(y)
Клауза: ¬D(y) ∨ U(y)

Попытка вывести противоречие:
- Из 2 (C(a)) и 1 (¬D(x) ∨ ¬C(x)): ¬D(a)
- Это не противоречит ¬D(y) ∨ U(y).

**Рассуждение некорректно.**

Контрмодель: множество датчан пусто, или все датчане умны.

**Ответ:**
- a) **Некорректно** — нет логической связи между посылками и заключением
- б) **Некорректно** — заключение не следует из посылок

---

### Задание 3 (15 баллов)
Кодовый замок входной двери имеет клавиатуру десятичных цифр для набора однозначного или двухзначного номера квартиры, кнопки “Сброс” и “Вызов”. Постройте граф переходов системы управления замком (узлы — состояния ввода, рёбра — нажатия клавиш).
---

#### Решение

**Состояния системы:**

- **S₀** — начальное состояние (ничего не введено)
- **S₁** — введена первая цифра d₁
- **S₂** — введены две цифры d₁d₂
- **Вызов** — состояние вызова (после нажатия "Вызов")

**Переходы:**

1. **Из S₀:**
   - Цифра 0-9 → S₁ (запоминаем первую цифру)
   - Сброс → S₀
   - Вызов → S₀ (нечего вызывать)

2. **Из S₁:**
   - Цифра 0-9 → S₂ (запоминаем вторую цифру)
   - Сброс → S₀
   - Вызов → Вызов квартиры d₁ → S₀

3. **Из S₂:**
   - Цифра 0-9 → S₂ (заменяем: новый номер = d₂·10 + новая цифра, или игнорируем)
   - Сброс → S₀
   - Вызов → Вызов квартиры d₁d₂ → S₀

**Граф переходов:**

```
        ┌─────────────────────────────────────┐
        │              Сброс                   │
        ↓                                      │
    ┌──────┐    0-9      ┌──────┐    0-9      ┌──────┐
    │  S₀  │ ─────────→  │  S₁  │ ─────────→  │  S₂  │
    └──────┘             └──────┘             └──────┘
        ↑                    │                    │
        │      Вызов         │       Вызов        │
        ├────────────────────┤                    │
        │                    ↓                    │
        │              [Вызов кв.]                │
        └─────────────────────────────────────────┘
                         Сброс
```

**Формальное описание:**

- Q = {S₀, S₁, S₂}
- Σ = {0, 1, ..., 9, Сброс, Вызов}
- q₀ = S₀
- δ(S₀, d) = S₁ для d ∈ {0-9}
- δ(S₁, d) = S₂ для d ∈ {0-9}
- δ(S₂, d) = S₂ для d ∈ {0-9} (или можно игнорировать лишние цифры)
- δ(любое, Сброс) = S₀
- δ(S₁, Вызов) = S₀ (с вызовом квартиры)
- δ(S₂, Вызов) = S₀ (с вызовом квартиры)

---
### Задание 4 (10 баллов)
Докажите методом Флойда, что программа

if x < y then z := y else z := x

вычисляет max(x,y) независимо от значений x и y.

---

#### Решение

**Программа:**
```
if x < y then z := y else z := x
```

**Спецификация:**
- Предусловие: true
- Постусловие: z = max(x, y)

**Метод Флойда для условного оператора:**

Нужно доказать:
1. {Pre ∧ B} S₁ {Post}
2. {Pre ∧ ¬B} S₂ {Post}

Где B = (x < y), S₁ = "z := y", S₂ = "z := x"

**Случай 1: x < y**

Предусловие: true ∧ (x < y) = (x < y)

wp("z := y", z = max(x,y)) = (y = max(x,y))

При x < y: max(x,y) = y, значит y = y ✓

Импликация: (x < y) → (y = max(x,y)) — истина.

**Случай 2: x ≥ y**

Предусловие: true ∧ ¬(x < y) = (x ≥ y)

wp("z := x", z = max(x,y)) = (x = max(x,y))

При x ≥ y: max(x,y) = x, значит x = x ✓

Импликация: (x ≥ y) → (x = max(x,y)) — истина.

**Вывод:**

Обе ветви условного оператора корректны относительно постусловия z = max(x,y).

**Программа корректна** — она вычисляет max(x,y) для любых значений x и y.

---

### Задание 5 (15 баллов)
Выразите формулой LTL следующие свойства бесконечных вычислений (в каждом состоянии выполняется не более одного события):

a) Если событие p выполняется в состоянии s_k, то событие q выполняется в одном из двух предыдущих состояний: в s_{k-1} или в s_{k-2}.

б) Событие p встретится на вычислении только одним неделимым блоком в нескольких последовательных состояниях: p p p ... (единственный непрерывный блок p).

в) После события p в следующий момент обязательно произойдёт событие q.

---

#### Решение

**a) Если p в s_k, то q в s_{k-1} или s_{k-2}**

В LTL нет оператора "прошлое", но можно выразить эквивалентно через будущее.

Условие: q ∨ X q должно выполняться за 2 шага до p.

Эквивалентно: если через 2 шага p, то сейчас или через шаг должно быть q.

**Формула:** G((X X p) → (q ∨ X q))

Расшифровка: всегда, если через 2 шага будет p, то сейчас или через 1 шаг есть q.

---

**б) Единственный непрерывный блок p**

Условия:
1. До первого p нет p (¬p до p)
2. После блока p нет p (G ¬p после конца блока)
3. Блок непрерывный (нет переключений внутри)

**Формула:** (¬p U (p U G ¬p)) ∨ G ¬p

Расшифровка: сначала ¬p, потом блок p, потом навсегда ¬p. Или p никогда не происходит.

Более точно: ¬p U (p ∧ X(p U G ¬p)) ∨ G ¬p ∨ (p U G ¬p)

Упрощённо: **(¬p W p) ∧ G(p → (p W G ¬p))**

Где W — слабый until.

---

**в) После p в следующий момент обязательно q**

**Формула:** G(p → X q)

Расшифровка: всегда, если p, то в следующем состоянии q.

---

### Задание 6 (10 баллов)
Для заданной структуры Крипке M проверьте выполнение свойства

E ( G F on ∧ G F off )

непосредственно по развертке вычислений M (unfolding). Ответ должен содержать развертку и пример вычисления.

Матрица смежности (порядок вершин: on, off) — все ячейки равны 1 (включая диагональ):

| from \\ to | on | off |
|---:|:-:|:-:|
| **on**  | 1 | 1 |
| **off** | 1 | 1 |

(Здесь присутствуют петли на каждом узле и рёбра в обе стороны между состояниями.)

---

#### Решение

**Структура Крипке:**

```
    ┌───┐
    │   ↓
   on ⇄ off
    ↑   │
    └───┘
```

Переходы: on → on, on → off, off → on, off → off

L(on) = {on}, L(off) = {off}

**Формула: E(G F on ∧ G F off)**

Это означает: существует путь, на котором **одновременно**:
- G F on — бесконечно часто on
- G F off — бесконечно часто off

**Развёртка (unfolding):**

```
on ─→ on ─→ off ─→ on ─→ off ─→ on ─→ ...
 │     │      │      │      │
 ↓     ↓      ↓      ↓      ↓
off   off    on     off    on
```

**Пример пути, удовлетворяющего формуле:**

π = on → off → on → off → on → off → ...

(чередование on и off)

На этом пути:
- G F on: в каждый нечётный момент (0, 2, 4, ...) выполняется on ✓
- G F off: в каждый чётный момент (1, 3, 5, ...) выполняется off ✓

Оба условия выполнены одновременно!

**Проверка:**

Путь π = (on, off, on, off, on, off, ...)

- G F on: для любого i существует j ≥ i такое, что π[j] = on. Да, т.к. on появляется бесконечно часто. ✓
- G F off: для любого i существует j ≥ i такое, что π[j] = off. Да, т.к. off появляется бесконечно часто. ✓

**Ответ:** Формула **E(G F on ∧ G F off) выполняется**.

**Путь-свидетель:** on → off → on → off → ... (бесконечное чередование)


