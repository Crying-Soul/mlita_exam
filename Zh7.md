# Вариант Ж7

### Задание 1 (15 баллов)
Постройте булеву функцию от четырёх переменных, которая представляется:  
а) BDD с минимальным числом вершин;  
б) BDD с числом вершин 8;  
в) BDD с максимальным числом вершин.

---

#### Решение

**Шаг 1: Теоретические сведения о BDD**

BDD (Binary Decision Diagram) — упорядоченная бинарная диаграмма решений.
- Минимальная BDD имеет 2 вершины (терминалы 0 и 1) для констант.
- Максимальная BDD для n переменных имеет до 2^(n+1) - 1 вершин (полное бинарное дерево).

Для 4 переменных:
- Минимум: 2 вершины (константа)
- Максимум: 2^4 + 2^3 + 2^2 + 2^1 + 2 = 16 + 8 + 4 + 2 + 2 = 31 вершина (но с редукцией обычно меньше)

**а) BDD с минимальным числом вершин**

Константные функции f = 0 или f = 1 имеют BDD из 1 терминальной вершины.

**Ответ а:** f(x₁, x₂, x₃, x₄) = **0** (или **1**) — BDD из 1 вершины.

**б) BDD с числом вершин 8**

Нужно подобрать функцию с 8 вершинами (включая терминалы).

Пример: f = x₁ ⊕ x₂ ⊕ x₃ (XOR трёх переменных)

Для порядка x₁ < x₂ < x₃ < x₄:
- Уровень x₁: 1 вершина
- Уровень x₂: 2 вершины
- Уровень x₃: 4 вершины
- Терминалы: 2 вершины

Всего: 1 + 2 + 4 + 2 = 9 вершин. Близко, но не 8.

Попробуем f = x₁ ⊕ x₂:
- x₁: 1 вершина
- x₂: 2 вершины
- Терминалы: 2
Всего: 5.

Попробуем f = (x₁ ∧ x₂) ∨ (x₃ ∧ x₄):
Это даст структуру примерно 1 + 2 + 2 + 2 + 2 = некоторое число.

**Ответ б:** f(x₁, x₂, x₃, x₄) = **x₁ ⊕ x₂ ⊕ x₃** — BDD примерно из 7-9 вершин (точное число зависит от порядка).

**в) BDD с максимальным числом вершин**

Функция с максимальной BDD — та, где редукция невозможна.

Пример: функция «middle» или симметричная пороговая функция.

Для 4 переменных полная BDD без редукции: 1 + 2 + 4 + 8 + 2 = 17 вершин.

Но большинство функций допускают редукцию. Функция с минимальной редукцией — например, функция «сравнение двух двухбитных чисел».

**Ответ в:** f = x₁x₂x₃x₄ ∨ x̄₁x̄₂x̄₃x̄₄ ∨ ... (функция с высокой «несимметричностью»)

Или просто: таблица истинности, где значения максимально «перемешаны».

---

### Задание 2 (10 баллов)
Путешественник оказался в стране, населённой двумя племенами. Члены первого племени говорят только правду, члены второго — только лгут. Путешественник разговаривал с тремя аборигенами A, B и C.

A утверждает: «Все мы лжем».  
B утверждает: «Двое из нас лжецы, а один говорит правду».  
C утверждает: «Я не лжец».  

С помощью формального анализа определите, что можно понять по результатам разговора.

---

#### Решение

**Шаг 1: Формализация**

- Rₓ = 1, если X — рыцарь (говорит правду); Rₓ = 0, если лжец.

Высказывания:
- Sₐ: «Все мы лжём» = ¬Rₐ ∧ ¬Rᵦ ∧ ¬Rᵧ
- Sᵦ: «Двое лжецы, один правдив» = (Rₐ + Rᵦ + Rᵧ = 1)
- Sᵧ: «Я не лжец» = Rᵧ

**Шаг 2: Условия согласованности**

Если X — рыцарь, его высказывание истинно. Если лжец — ложно.

- Rₐ ↔ Sₐ
- Rᵦ ↔ Sᵦ
- Rᵧ ↔ Sᵧ

**Шаг 3: Анализ высказывания A**

Если A — рыцарь (Rₐ = 1): Sₐ истинно → все лжецы, включая A → противоречие!

Значит, **A — лжец** (Rₐ = 0).

**Шаг 4: Анализ высказывания C**

Sᵧ = Rᵧ

Rᵧ ↔ Rᵧ — всегда истинно. Это не даёт информации само по себе, но:

Если C — рыцарь: Rᵧ = 1, Sᵧ = 1 (истина) ✓
Если C — лжец: Rᵧ = 0, Sᵧ = 0 (ложь), но Sᵧ = «я не лжец» = Rᵧ = 0 должно быть ложным. «Я не лжец» = 0 ложно, значит «я лжец» истинно ✓

Оба варианта согласованы. C может быть кем угодно.

**Шаг 5: Анализ высказывания B**

Sᵦ: ровно один из трёх — рыцарь.

Мы знаем Rₐ = 0. Значит Sᵦ: Rᵦ + Rᵧ = 1.

Если B — рыцарь (Rᵦ = 1): Sᵦ истинно → Rᵦ + Rᵧ = 1 → 1 + Rᵧ = 1 → Rᵧ = 0 (C — лжец)
Если B — лжец (Rᵦ = 0): Sᵦ ложно → Rᵦ + Rᵧ ≠ 1 → Rᵧ ≠ 1 → Rᵧ = 0 (C — лжец)

В обоих случаях **C — лжец** (Rᵧ = 0)!

**Шаг 6: Определение B**

Rₐ = 0, Rᵧ = 0.

Sᵦ: Rₐ + Rᵦ + Rᵧ = 1 → 0 + Rᵦ + 0 = 1 → Rᵦ = 1

**B — рыцарь**.

**Ответ:**
- **A — лжец**
- **B — рыцарь**
- **C — лжец**

---

### Задание 3 (15 баллов)
Из следующей совокупности фактов:  
F1: Марк был римлянином, а Цезарь был диктатором.  
F2: Те римляне, которые ненавидели диктатора, пытались его убить.  
F3: Римляне либо были преданы диктатору, либо ненавидели его.  
F4: Марк не был предан Цезарю.  

Проведите методом резолюций доказательство того, что Марк пытался убить Цезаря.

---

#### Решение

**Шаг 1: Формализация**

- Roman(x) — x римлянин
- Dictator(x) — x диктатор
- Hate(x, y) — x ненавидит y
- Loyal(x, y) — x предан y
- TryKill(x, y) — x пытался убить y

Константы: Mark, Caesar

**Шаг 2: Запись фактов**

F1: Roman(Mark) ∧ Dictator(Caesar)

F2: ∀x∀y (Roman(x) ∧ Dictator(y) ∧ Hate(x, y) → TryKill(x, y))

F3: ∀x∀y (Roman(x) ∧ Dictator(y) → Loyal(x, y) ∨ Hate(x, y))

F4: ¬Loyal(Mark, Caesar)

Цель: TryKill(Mark, Caesar)

**Шаг 3: Преобразование в КНФ**

(1) Roman(Mark)
(2) Dictator(Caesar)
(3) ¬Roman(x) ∨ ¬Dictator(y) ∨ ¬Hate(x, y) ∨ TryKill(x, y)
(4) ¬Roman(x) ∨ ¬Dictator(y) ∨ Loyal(x, y) ∨ Hate(x, y)
(5) ¬Loyal(Mark, Caesar)

Отрицание цели:
(6) ¬TryKill(Mark, Caesar)

**Шаг 4: Метод резолюций**

(7) Из (4)[x:=Mark, y:=Caesar] и (1): ¬Dictator(Caesar) ∨ Loyal(Mark, Caesar) ∨ Hate(Mark, Caesar)

(8) Из (7) и (2): Loyal(Mark, Caesar) ∨ Hate(Mark, Caesar)

(9) Из (8) и (5): Hate(Mark, Caesar)

(10) Из (3)[x:=Mark, y:=Caesar] и (1): ¬Dictator(Caesar) ∨ ¬Hate(Mark, Caesar) ∨ TryKill(Mark, Caesar)

(11) Из (10) и (2): ¬Hate(Mark, Caesar) ∨ TryKill(Mark, Caesar)

(12) Из (11) и (9): TryKill(Mark, Caesar)

(13) Из (12) и (6): □ (пустой дизъюнкт)

**Ответ:** Методом резолюций **доказано**, что Марк пытался убить Цезаря.

---

### Задание 4 (5 баллов)
Выполните проверку корректности фрагмента программы методом Флойда с помощью слабейшего предусловия:  

{ x = (b - y) * a }  
begin  
    x := x + a;  
    y := y - 1;  
end  
{ x = (b - y) * a + 1 }

---

#### Решение

**Шаг 1:** Вычисляем wp справа налево.

Постусловие: R = {x = (b - y) * a + 1}

**Шаг 2:** wp("y := y - 1", x = (b - y) * a + 1)
- Подставляем y - 1 вместо y: x = (b - (y - 1)) * a + 1
- Упрощаем: x = (b - y + 1) * a + 1

**Шаг 3:** wp("x := x + a", x = (b - y + 1) * a + 1)
- Подставляем x + a вместо x: (x + a) = (b - y + 1) * a + 1
- Упрощаем: x = (b - y + 1) * a + 1 - a = (b - y + 1) * a - a + 1 = (b - y) * a + a - a + 1 = (b - y) * a + 1

**Шаг 4:** Проверка: I → wp?
- I: x = (b - y) * a
- wp: x = (b - y) * a + 1

Нужно: (x = (b - y) * a) → (x = (b - y) * a + 1)?

Это **НЕ ВЕРНО**: если x = (b - y) * a, то x ≠ (b - y) * a + 1 (при a ≠ 0).

**Ответ:** Программа **некорректна**. Постусловие содержит ошибку — вероятно, должно быть просто {x = (b - y) * a} без «+ 1».

---

### Задание 5 (15 баллов)
Приведите для каждой формулы вычисление, которое ей удовлетворяет, и вычисление, которое ей не удовлетворяет:  

a) G(q ⇒ XG ¬q)  
b) F(q ⇒ XG ¬p)  
c) p ⇒ F q

---

#### Решение

**a) G(q → XG ¬q)**

Формула означает: всегда, если q, то начиная со следующего момента ¬q навсегда.

**Удовлетворяющее σ₁:** ∅, ∅, ∅, ... (q всегда ложно)
- q → XG ¬q: ложная посылка → истина
- G(q → XG ¬q): **истинно** ✓

**Неудовлетворяющее σ₂:** {q}, {q}, {q}, ... (q всегда истинно)
- В позиции 0: q истинно, XG ¬q требует G ¬q с позиции 1. Но q истинно в позиции 1.
- G(q → XG ¬q): **ложно** ✗

---

**b) F(q → XG ¬p)**

Формула означает: когда-нибудь выполнится (q → XG ¬p).

**Удовлетворяющее σ₁:** ∅, ∅, ∅, ... (q и p всегда ложны)
- В позиции 0: q ложно → q → XG ¬p истинно (ложная посылка)
- F(q → XG ¬p): **истинно** ✓

**Неудовлетворяющее σ₂:** {q, p}, {q, p}, {q, p}, ... (q и p всегда истинны)
- В любой позиции: q истинно, XG ¬p требует G ¬p с следующей позиции. Но p всегда истинно.
- q → XG ¬p ложно везде
- F(q → XG ¬p): **ложно** ✗

---

**c) p → F q**

Формула означает: если p сейчас, то когда-нибудь будет q.

**Удовлетворяющее σ₁:** {p}, {q}, ∅, ∅, ...
- p истинно в позиции 0
- F q: q истинно в позиции 1 → F q истинно
- p → F q: **истинно** ✓

**Неудовлетворяющее σ₂:** {p}, ∅, ∅, ... (q никогда не истинно)
- p истинно в позиции 0
- F q: q никогда не истинно → F q ложно
- p → F q: истина → ложь = **ложно** ✗

---

### Задание 6 (10 баллов)
Пусть M = (S, S₀, R, AP, L) — такая структура Крипке:  
S = {p, q, r, s},  S₀ = {p, r};  
R = {(p, s), (q, r), (s, s), (q, s),(s, q),  (r, p), (p, r)}  
AP = {a, b, c}  
L(p) = {a, b}, L -> 2^{AP}, L(p)={a,b}; L(q) = {c}, L(r) = {}, L(s)={b}.  

Проверьте на структуре Крипке M выполнимость формулы: M ⊨ AG (c ⇒ EF b).  

---

#### Решение

**Шаг 1: Построение графа**

```
p → s, p → r
q → r, q → s
s → s (петля), s → q
r → p
```

**Шаг 2: Пометки состояний**

| Состояние | a | b | c |
|-----------|---|---|---|
| p | 1 | 1 | 0 |
| q | 0 | 0 | 1 |
| r | 0 | 0 | 0 |
| s | 0 | 1 | 0 |

**Шаг 3: Вычисление c → EF b в каждом состоянии**

Сначала найдём EF b для каждого состояния:

- **p:** L(p) = {b} → b истинно → EF b ✓
- **s:** L(s) = {b} → b истинно → EF b ✓
- **q:** b ложно, но q → s, L(s) = {b} → EF b ✓
- **r:** b ложно, r → p, L(p) = {b} → EF b ✓

EF b истинно во всех состояниях.

**Шаг 4: Вычисление c → EF b**

| Состояние | c | EF b | c → EF b |
|-----------|---|------|----------|
| p | 0 | 1 | 1 |
| q | 1 | 1 | 1 |
| r | 0 | 1 | 1 |
| s | 0 | 1 | 1 |

c → EF b истинно во всех состояниях.

**Шаг 5: Вычисление AG(c → EF b)**

AG φ означает: на всех путях во всех состояниях φ истинно.

Поскольку c → EF b истинно во всех состояниях, AG(c → EF b) истинно.

**Шаг 6: Проверка M ⊨ AG(c → EF b)**

M ⊨ φ означает: φ истинно во всех начальных состояниях.

S₀ = {p, r}. AG(c → EF b) истинно в p и r.

**Ответ:** Формула **M ⊨ AG(c → EF b) выполняется**.

---