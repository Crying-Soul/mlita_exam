# Вариант Ж7

### Задание 1 (15 баллов)
Постройте булеву функцию от четырёх переменных, которая представляется:  
а) BDD с минимальным числом вершин;  
б) BDD с числом вершин 8;  
в) BDD с максимальным числом вершин.

---

#### Решение

**Шаг 1: Теоретические сведения о BDD**

BDD (Binary Decision Diagram) — упорядоченная бинарная диаграмма решений с двумя правилами редукции:
1. **Удаление изоморфных поддеревьев** — если два узла имеют одинаковые поддеревья, они объединяются
2. **Удаление избыточных узлов** — если оба ребра из узла ведут в одно место, узел удаляется

**Подсчёт вершин:** Считаем все вершины включая терминальные (0 и 1).

**а) BDD с минимальным числом вершин**

Константные функции f = 0 или f = 1 имеют BDD из **1 терминальной вершины**.

**Ответ а:** f(x₁, x₂, x₃, x₄) = **0** (или **1**) — BDD из **1 вершины**.

```
    [0]     или     [1]
```

---

**б) BDD с числом вершин 8**

Рассмотрим функцию f = (x₁ ∧ x₂) ∨ (x₃ ∧ x₄) при порядке x₁ < x₂ < x₃ < x₄:

```
           x₁
          /  \
        0/    \1
        /      \
      x₃        x₂
     /  \      /  \
   0/   1\   0/   1\
   /     \   /     \
  x₄     x₄  x₃    [1]
 / \    / \ / \
0  1   0  1 0  1
|  |   |  | |  |
[0][1] [0][1][0][1]
```

После редукции (объединение одинаковых терминалов и поддеревьев):

**Структура BDD:**
```
              x₁
            0/  \1
            /    \
          x₃      x₂
        0/ \1   0/ \1
        /   \   /   \
      x₄   [1] x₃   [1]
     0/ \1    0/ \1
     /   \    /   \
   [0]  [1] x₄   [1]
           0/ \1
           /   \
         [0]  [1]
```

Подсчёт: x₁(1) + x₂(1) + x₃(2) + x₄(2) + терминалы(2) = **8 вершин** ✓

**Ответ б:** f(x₁, x₂, x₃, x₄) = **(x₁ ∧ x₂) ∨ (x₃ ∧ x₄)** — BDD из **8 вершин**.

---

**в) BDD с максимальным числом вершин**

Для 4 переменных максимальное число вершин в редуцированной BDD достигается для функций типа "сравнение" или "скрытое сложение".

Функция f = x₁x₃ ⊕ x₂x₄ (сравнение двух 2-битных чисел на <) или **средняя симметрическая функция** S₂⁴ (ровно 2 переменные равны 1):

S₂⁴(x₁,x₂,x₃,x₄) = (x₁⊕x₂⊕x₃⊕x₄=0) ∧ (x₁∨x₂∨x₃∨x₄=1)

Для порядка x₁ < x₂ < x₃ < x₄:
- Уровень x₁: 1 вершина
- Уровень x₂: 2 вершины  
- Уровень x₃: 3 вершины
- Уровень x₄: 4 вершины
- Терминалы: 2 вершины

**Всего: 1 + 2 + 3 + 4 + 2 = 12 вершин**

```
                 x₁
               0/  \1
               /    \
             x₂      x₂'
           0/ \1   0/ \1
           /   \   /   \
         x₃    x₃' x₃'' x₃'''
         ...   ...  ...  ...
```

**Ответ в:** f = S₂⁴(x₁,x₂,x₃,x₄) — функция «ровно 2 единицы» — BDD из **12 вершин**.

---

### Задание 2 (10 баллов)
Путешественник оказался в стране, населённой двумя племенами. Члены первого племени говорят только правду, члены второго — только лгут. Путешественник разговаривал с тремя аборигенами A, B и C.

A утверждает: «Все мы лжем».  
B утверждает: «Двое из нас лжецы, а один говорит правду».  
C утверждает: «Я не лжец».  

С помощью формального анализа определите, что можно понять по результатам разговора.

---

#### Решение

**Шаг 1: Формализация**

- Rₓ = 1, если X — рыцарь (говорит правду); Rₓ = 0, если лжец.

Высказывания:
- Sₐ: «Все мы лжём» = ¬Rₐ ∧ ¬Rᵦ ∧ ¬Rᵧ
- Sᵦ: «Двое лжецы, один правдив» = (Rₐ + Rᵦ + Rᵧ = 1)
- Sᵧ: «Я не лжец» = Rᵧ

**Шаг 2: Условия согласованности**

Если X — рыцарь, его высказывание истинно. Если лжец — ложно.

- Rₐ ↔ Sₐ
- Rᵦ ↔ Sᵦ
- Rᵧ ↔ Sᵧ

**Шаг 3: Анализ высказывания A**

Если A — рыцарь (Rₐ = 1): Sₐ истинно → все лжецы, включая A → противоречие!

Значит, **A — лжец** (Rₐ = 0).

**Шаг 4: Анализ высказывания C**

Sᵧ = Rᵧ

Rᵧ ↔ Rᵧ — всегда истинно. Это не даёт информации само по себе, но:

Если C — рыцарь: Rᵧ = 1, Sᵧ = 1 (истина) ✓
Если C — лжец: Rᵧ = 0, Sᵧ = 0 (ложь), но Sᵧ = «я не лжец» = Rᵧ = 0 должно быть ложным. «Я не лжец» = 0 ложно, значит «я лжец» истинно ✓

Оба варианта согласованы. C может быть кем угодно.

**Шаг 5: Анализ высказывания B**

Sᵦ: ровно один из трёх — рыцарь.

Мы знаем Rₐ = 0. Значит Sᵦ: Rᵦ + Rᵧ = 1.

Если B — рыцарь (Rᵦ = 1): Sᵦ истинно → Rᵦ + Rᵧ = 1 → 1 + Rᵧ = 1 → Rᵧ = 0 (C — лжец)
Если B — лжец (Rᵦ = 0): Sᵦ ложно → Rᵦ + Rᵧ ≠ 1 → Rᵧ ≠ 1 → Rᵧ = 0 (C — лжец)

В обоих случаях **C — лжец** (Rᵧ = 0)!

**Шаг 6: Определение B**

Rₐ = 0, Rᵧ = 0.

Sᵦ: Rₐ + Rᵦ + Rᵧ = 1 → 0 + Rᵦ + 0 = 1 → Rᵦ = 1

**B — рыцарь**.

**Ответ:**
- **A — лжец**
- **B — рыцарь**
- **C — лжец**

---

### Задание 3 (15 баллов)
Из следующей совокупности фактов:  
F1: Марк был римлянином, а Цезарь был диктатором.  
F2: Те римляне, которые ненавидели диктатора, пытались его убить.  
F3: Римляне либо были преданы диктатору, либо ненавидели его.  
F4: Марк не был предан Цезарю.  

Проведите методом резолюций доказательство того, что Марк пытался убить Цезаря.

---

#### Решение

**Шаг 1: Формализация**

- Roman(x) — x римлянин
- Dictator(x) — x диктатор
- Hate(x, y) — x ненавидит y
- Loyal(x, y) — x предан y
- TryKill(x, y) — x пытался убить y

Константы: Mark, Caesar

**Шаг 2: Запись фактов**

F1: Roman(Mark) ∧ Dictator(Caesar)

F2: ∀x∀y (Roman(x) ∧ Dictator(y) ∧ Hate(x, y) → TryKill(x, y))

F3: ∀x∀y (Roman(x) ∧ Dictator(y) → Loyal(x, y) ∨ Hate(x, y))

F4: ¬Loyal(Mark, Caesar)

Цель: TryKill(Mark, Caesar)

**Шаг 3: Преобразование в КНФ**

(1) Roman(Mark)
(2) Dictator(Caesar)
(3) ¬Roman(x) ∨ ¬Dictator(y) ∨ ¬Hate(x, y) ∨ TryKill(x, y)
(4) ¬Roman(x) ∨ ¬Dictator(y) ∨ Loyal(x, y) ∨ Hate(x, y)
(5) ¬Loyal(Mark, Caesar)

Отрицание цели:
(6) ¬TryKill(Mark, Caesar)

**Шаг 4: Метод резолюций**

(7) Из (4)[x:=Mark, y:=Caesar] и (1): ¬Dictator(Caesar) ∨ Loyal(Mark, Caesar) ∨ Hate(Mark, Caesar)

(8) Из (7) и (2): Loyal(Mark, Caesar) ∨ Hate(Mark, Caesar)

(9) Из (8) и (5): Hate(Mark, Caesar)

(10) Из (3)[x:=Mark, y:=Caesar] и (1): ¬Dictator(Caesar) ∨ ¬Hate(Mark, Caesar) ∨ TryKill(Mark, Caesar)

(11) Из (10) и (2): ¬Hate(Mark, Caesar) ∨ TryKill(Mark, Caesar)

(12) Из (11) и (9): TryKill(Mark, Caesar)

(13) Из (12) и (6): □ (пустой дизъюнкт)

**Ответ:** Методом резолюций **доказано**, что Марк пытался убить Цезаря.

---

### Задание 4 (5 баллов)
Выполните проверку корректности фрагмента программы методом Флойда с помощью слабейшего предусловия:  

{ x = (b - y) * a }  
begin  
    x := x + a;  
    y := y - 1;  
end  
{ x = (b - y) * a + 1 }

---

#### Решение

**Шаг 1:** Вычисляем wp справа налево.

Постусловие: R = {x = (b - y) * a + 1}

**Шаг 2:** wp("y := y - 1", x = (b - y) * a + 1)
- Подставляем y - 1 вместо y: x = (b - (y - 1)) * a + 1
- Упрощаем: x = (b - y + 1) * a + 1

**Шаг 3:** wp("x := x + a", x = (b - y + 1) * a + 1)
- Подставляем x + a вместо x: (x + a) = (b - y + 1) * a + 1
- Упрощаем: x = (b - y + 1) * a + 1 - a = (b - y + 1) * a - a + 1 = (b - y) * a + a - a + 1 = (b - y) * a + 1

**Шаг 4:** Проверка: I → wp?
- I: x = (b - y) * a
- wp: x = (b - y) * a + 1

Нужно: (x = (b - y) * a) → (x = (b - y) * a + 1)?

Это **НЕ ВЕРНО**: если x = (b - y) * a, то x ≠ (b - y) * a + 1 (при a ≠ 0).

**Ответ:** Программа **некорректна**. Постусловие содержит ошибку — вероятно, должно быть просто {x = (b - y) * a} без «+ 1».

---

### Задание 5 (15 баллов)
Приведите для каждой формулы вычисление, которое ей удовлетворяет, и вычисление, которое ей не удовлетворяет:  

a) G(q ⇒ XG ¬q)  
b) F(q ⇒ XG ¬p)  
c) p ⇒ F q

---

#### Решение

**a) G(q → XG ¬q)**

Формула означает: всегда, если q, то начиная со следующего момента ¬q навсегда.

**Удовлетворяющее σ₁:** ∅, ∅, ∅, ... (q всегда ложно)
- q → XG ¬q: ложная посылка → истина
- G(q → XG ¬q): **истинно** ✓

**Неудовлетворяющее σ₂:** {q}, {q}, {q}, ... (q всегда истинно)
- В позиции 0: q истинно, XG ¬q требует G ¬q с позиции 1. Но q истинно в позиции 1.
- G(q → XG ¬q): **ложно** ✗

---

**b) F(q → XG ¬p)**

Формула означает: когда-нибудь выполнится (q → XG ¬p).

**Удовлетворяющее σ₁:** ∅, ∅, ∅, ... (q и p всегда ложны)
- В позиции 0: q ложно → q → XG ¬p истинно (ложная посылка)
- F(q → XG ¬p): **истинно** ✓

**Неудовлетворяющее σ₂:** {q, p}, {q, p}, {q, p}, ... (q и p всегда истинны)
- В любой позиции: q истинно, XG ¬p требует G ¬p с следующей позиции. Но p всегда истинно.
- q → XG ¬p ложно везде
- F(q → XG ¬p): **ложно** ✗

---

**c) p → F q**

Формула означает: если p сейчас, то когда-нибудь будет q.

**Удовлетворяющее σ₁:** {p}, {q}, ∅, ∅, ...
- p истинно в позиции 0
- F q: q истинно в позиции 1 → F q истинно
- p → F q: **истинно** ✓

**Неудовлетворяющее σ₂:** {p}, ∅, ∅, ... (q никогда не истинно)
- p истинно в позиции 0
- F q: q никогда не истинно → F q ложно
- p → F q: истина → ложь = **ложно** ✗

---

### Задание 6 (10 баллов)
Пусть M = (S, S₀, R, AP, L) — такая структура Крипке:  
S = {p, q, r, s},  S₀ = {p, r};  
R = {(p, s), (q, r), (s, s), (q, s),(s, q),  (r, p), (p, r)}  
AP = {a, b, c}  
L(p) = {a, b}, L -> 2^{AP}, L(p)={a,b}; L(q) = {c}, L(r) = {}, L(s)={b}.  

Проверьте на структуре Крипке M выполнимость формулы: M ⊨ AG (c ⇒ EF b).  

---

#### Решение

**Шаг 1: Построение графа структуры Крипке**

```
Состояния и их метки:
┌─────────────────────────────────────────────────────────┐
│  p: {a,b}    q: {c}    r: {}    s: {b}                  │
└─────────────────────────────────────────────────────────┘

Граф переходов:
                    ┌───────────┐
                    │           │
                    ▼           │
    ┌────┐       ┌────┐       ┌────┐
    │ p  │◄──────│ r  │       │ q  │
    │{a,b}│       │ {} │◄──────│{c} │
    └────┘       └────┘       └────┘
       │                         │
       │  ┌──────────────────────┘
       │  │
       ▼  ▼
    ┌─────────┐
    │    s    │◄──┐
    │   {b}   │───┘ (петля)
    └─────────┘
         │
         │
         ▼
       ┌────┐
       │ q  │
       │{c} │
       └────┘

Полный список переходов:
  p → s,  p → r
  q → r,  q → s
  s → s (петля), s → q
  r → p
```

**Шаг 2: Таблица атомарных предложений**

| Состояние | a | b | c |
|-----------|---|---|---|
| p | ✓ | ✓ | ✗ |
| q | ✗ | ✗ | ✓ |
| r | ✗ | ✗ | ✗ |
| s | ✗ | ✓ | ✗ |

**Шаг 3: Вычисление EF b (достижимость b)**

EF b = μZ.(b ∨ EX Z) — состояния, из которых достижимо b.

**Итерация 0:** Z₀ = ∅

**Итерация 1:** Z₁ = {s | b ∈ L(s)} = {p, s}

**Итерация 2:** Z₂ = Z₁ ∪ {s | ∃t: (s,t) ∈ R ∧ t ∈ Z₁}
- q: q → s, s ∈ Z₁ ✓ → добавляем q
- r: r → p, p ∈ Z₁ ✓ → добавляем r
- Z₂ = {p, s, q, r}

**Итерация 3:** Z₃ = Z₂ (все состояния уже включены)

**EF b = {p, q, r, s}** — EF b истинно во всех состояниях.

**Шаг 4: Вычисление c → EF b**

| Состояние | c | EF b | c → EF b |
|-----------|---|------|----------|
| p | 0 | 1 | 0→1 = **1** |
| q | 1 | 1 | 1→1 = **1** |
| r | 0 | 1 | 0→1 = **1** |
| s | 0 | 1 | 0→1 = **1** |

**c → EF b истинно во всех состояниях.**

**Шаг 5: Вычисление AG(c → EF b)**

AG φ = νZ.(φ ∧ AX Z) — φ истинно на всех путях во всех состояниях.

Поскольку φ = (c → EF b) истинно во ВСЕХ состояниях {p, q, r, s}, то AG(c → EF b) также истинно во всех состояниях.

**Шаг 6: Проверка M ⊨ AG(c → EF b)**

M ⊨ φ означает: φ истинно во всех начальных состояниях S₀ = {p, r}.

- В p: AG(c → EF b) = 1 ✓
- В r: AG(c → EF b) = 1 ✓

**Ответ:** **M ⊨ AG(c → EF b) — формула выполняется** ✓

**Пояснение:** Единственное состояние с c = 1 это q. Из q достижимо s (где b = 1) через переход q → s. Следовательно, EF b выполняется в q, и импликация c → EF b истинна везде.

---